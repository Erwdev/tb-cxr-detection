# -*- coding: utf-8 -*-
"""morphological processing.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1XlBxfx3foLVSnooZYEggqo5LybgNGcp4
"""

import numpy as np
import matplotlib.pyplot as plt
import cv2
import random
import math

image = cv2.imread('/content/91sknOyLQXL.jpg.jpeg')

image = cv2.cvtColor(image, cv2.COLOR_BGR2RGB)

plt.imshow(image)
plt.show()

# reshape image â†’ 2D array
pixel_values = image.reshape((-1, 3))
pixel_values = np.float32(pixel_values)

#K means clustering
k = 3
criteria = (cv2.TERM_CRITERIA_EPS + cv2.TERM_CRITERIA_MAX_ITER, 100, 0.2)

compactness, labels, centers = cv2.kmeans(
    pixel_values,
    K=k,
    bestLabels=None,
    criteria=criteria,
    attempts=10,
    flags=cv2.KMEANS_PP_CENTERS
)

# =================================
# RECONSTRUCT SEGMENTED IMAGE
# =================================
centers = np.uint8(centers)
segmented_data = centers[labels.flatten()]
segmented_image = segmented_data.reshape(image.shape)

plt.imshow(segmented_image)
plt.title("Hasil Segmentasi K-Means (Fast)")
plt.axis('off')
plt.show()

cv2.imwrite("hasil_segmentasi.png", cv2.cvtColor(segmented_image, cv2.COLOR_RGB2BGR))


# Buat mask percluster
h, w, c = image.shape
labels_2d = labels.reshape((h, w))

masks = []
for i in range(k):
    mask = (labels_2d == i).astype(np.uint8)
    masks.append(mask)
    cv2.imwrite(f"mask_cluster_{i+1}.png", mask * 255)

# tampilkan mask
fig, ax = plt.subplots(1, k, figsize=(12, 4))
for i in range(k):
    ax[i].imshow(masks[i], cmap='gray')
    ax[i].set_title(f"Mask Cluster {i+1}")
    ax[i].axis('off')
plt.show()

import cv2
import numpy as np
import matplotlib.pyplot as plt
import glob

#Otsu Thresholding
def otsu_threshold(img):
    # Kamu tetap bisa pakai versi manualmu
    hist, bins = np.histogram(img.flatten(), 256, [0, 256])
    total = img.size
    sum_total = np.dot(np.arange(256), hist)

    sumB = 0
    wB = 0
    max_var = 0
    threshold = 0

    for t in range(256):
        wB += hist[t]
        if wB == 0:
            continue
        wF = total - wB
        if wF == 0:
            break
        sumB += t * hist[t]
        mB = sumB / wB
        mF = (sum_total - sumB) / wF
        var_between = wB * wF * (mB - mF) ** 2
        if var_between > max_var:
            max_var = var_between
            threshold = t

    print("Threshold Otsu terpilih :", threshold)
    return (img > threshold).astype(np.uint8)


#Definisi FUngsi berisi morphological process
def erosi(img, kernel):
    return cv2.erode(img, kernel, iterations=1)

def dilatasi(img, kernel):
    return cv2.dilate(img, kernel, iterations=1)

def opening(img, kernel):
    return cv2.morphologyEx(img, cv2.MORPH_OPEN, kernel)

def closing(img, kernel):
    return cv2.morphologyEx(img, cv2.MORPH_CLOSE, kernel)


#Membuat kernel dan gambar gambar yang sudah di masking
kernel = np.ones((3, 3), np.uint8)
mask_files = sorted(glob.glob("mask_cluster_*.png"))

for mask_file in mask_files:
    print("Memproses file:", mask_file)

    # baca masker grayscale
    mask = cv2.imread(mask_file, cv2.IMREAD_GRAYSCALE)

    # Otsu manual
    mask_bin = otsu_threshold(mask)

    # convert ke 0/255 untuk morphology OpenCV
    mask_bin_255 = (mask_bin * 255).astype(np.uint8)

    # --- operasi morfologi cepat ---
    eroded = erosi(mask_bin_255, kernel)
    dilated = dilatasi(mask_bin_255, kernel)
    opened = opening(mask_bin_255, kernel)
    closed = closing(mask_bin_255, kernel)

#visualisasi
    hasil = {
        "Original": mask,
        "Otsu Binary": mask_bin_255,
        "Erosi": eroded,
        "Dilatasi": dilated,
        "Opening": opened,
        "Closing": closed
    }

    for title, img in hasil.items():
        plt.figure(figsize=(8, 8))
        plt.imshow(img, cmap='gray')
        plt.title(f"{title} - {mask_file}")
        plt.axis('off')
        plt.show()

import cv2
import numpy as np
import matplotlib.pyplot as plt
import glob

#Otsu Thresholding
def otsu_threshold(img):
    # Kamu tetap bisa pakai versi manualmu
    hist, bins = np.histogram(img.flatten(), 256, [0, 256])
    total = img.size
    sum_total = np.dot(np.arange(256), hist)

    sumB = 0
    wB = 0
    max_var = 0
    threshold = 0

    for t in range(256):
        wB += hist[t]
        if wB == 0:
            continue
        wF = total - wB
        if wF == 0:
            break
        sumB += t * hist[t]
        mB = sumB / wB
        mF = (sum_total - sumB) / wF
        var_between = wB * wF * (mB - mF) ** 2
        if var_between > max_var:
            max_var = var_between
            threshold = t

    print("Threshold Otsu terpilih :", threshold)
    return (img > threshold).astype(np.uint8)


#Definisi FUngsi berisi morphological process
def erosi(img, kernel):
    return cv2.erode(img, kernel, iterations=1)

def dilatasi(img, kernel):
    return cv2.dilate(img, kernel, iterations=1)

def opening(img, kernel):
    return cv2.morphologyEx(img, cv2.MORPH_OPEN, kernel)

def closing(img, kernel):
    return cv2.morphologyEx(img, cv2.MORPH_CLOSE, kernel)


#Membuat kernel dan gambar gambar yang sudah di masking
kernel = np.ones((5, 5), np.uint8)
mask_files = sorted(glob.glob("mask_cluster_*.png"))

for mask_file in mask_files:
    print("Memproses file:", mask_file)

    # baca masker grayscale
    mask = cv2.imread(mask_file, cv2.IMREAD_GRAYSCALE)

    # Otsu manual
    mask_bin = otsu_threshold(mask)

    # convert ke 0/255 untuk morphology OpenCV
    mask_bin_255 = (mask_bin * 255).astype(np.uint8)

    # --- operasi morfologi cepat ---
    eroded = erosi(mask_bin_255, kernel)
    dilated = dilatasi(mask_bin_255, kernel)
    opened = opening(mask_bin_255, kernel)
    closed = closing(mask_bin_255, kernel)

#visualisasi
    hasil = {
        "Original": mask,
        "Otsu Binary": mask_bin_255,
        "Erosi": eroded,
        "Dilatasi": dilated,
        "Opening": opened,
        "Closing": closed
    }

    for title, img in hasil.items():
        plt.figure(figsize=(8, 8))
        plt.imshow(img, cmap='gray')
        plt.title(f"{title} - {mask_file}")
        plt.axis('off')
        plt.show()